---
title: "ソフトウェア設計のマイブーム"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["design", "poem"]
published: false
---

まとまってない記事はもっと雑多な感じの別の媒体に書くことにしているのだが、そうは言っても考え方があり、それに基づいてgit repositoryを作るので、参照先になるドキュメントがあったほうがよく、それはやはり技術記事だろうというところで書く。  

# intro
新卒の時の上司に「君は野武士だね」と言われたのが、割と印象に残っているのだけど、これは自分で理屈決めて進めちゃうところがあるので、ちゃんと本とか読んで一般的に流通している理論や方法論に習うこともしよう！という話だった。  
それはその通りで、この記事はマインドセットの話ではないのでこれ以上言及しないが、反省してなるべく書籍を読んでいる。だが最近は書籍を読む時間がなく、ちょっと自分の理論が暴走気味な気がする。  
とはいえ、個人の開発も会社の仕事も進んでいくわけで、ソフトウェア設計において、何を指針にしていくか、決めて置かないとスムーズじゃない。  
今後アップデートされるとしても、とりあえずそういった自分の関わるプロジェクトから参照するドキュメントとして、ソフトウェア設計の方針や理論について、まとめて置きたい。  

# 大枠の設計
大枠の設計とはなんなのか。新卒のときはSIだったので、要件定義->基本設計->詳細設計->コーディングだった。  
いまは自社のweb開発なので、PdMがざっくりした機能を整理して、それに対して機能を詳細に定義して、詳細設計してコーディングという感じ。  
個人で開発する際は、何がほしいのか？というのを自分で考えて、それを実現するために、どういう機能がいるか考え、それが既存のアプリケーションなどで代替できないか検討する。  

## requirement

いずれにしろ、まず最初は何がほしいのか？だろう。  
ほしいイメージがなければ、何もできない。解決したい課題と言ってもいいかもしれない。  
後述するが、これをrequirementと呼ぶことにしている。  

概念には名前がついていたほうがいい。なので名前をつけるのだが、既にある概念を正しく認識できているかわからない。なので書籍を読めという話だが、時間がないので勝手に命名する。  
既にある概念は、手垢がついてバズワードと化しているものも少なくない。そういったものは定義が正確ではないのでいずれにしても使いたくない。ドメイン駆動設計という単語にも同様の印象を抱いている。  

requirementはとにかく、何がほしいか、ほしい人の言葉で書く。術後がほしいではなく、性質を示し始めたらそれは次のconsiderationの領域になるので辞める。  

## consideration
ドメイン駆動設計は、バズワードと化しているという印象だが、実際には書籍を読んでちゃんと理解して、向き合うべきだろう。  
辞書的な意味でいうと「ユビキタス言語を用いてドメインエキスパートと会話しながら設計する」だろう。いわゆる戦略的なDDDというものだと思っている。  

実際にはドメインエキスパートなどという人は世の中に存在するのだろうか。ユビキタス言語というものが仮にあったとしても、生産的な会話が常に行えるイメージは乏しい。  
新卒の時のSIには、金融部門、生産部門などで部署が別れていた。推測するに、金融系のシステムの勘所、工場系システムの勘所というのは、部署内のベテランにノウハウが溜まっているのではないだろうか？  
それらのベテランこそがドメインエキスパートであるし、現職のweb企業であるならば、古株になりつつある自分こそがドメインエキスパートたるべきなのではないか。  
ドメインエキスパートにはその分野のシステムのノウハウを色々持っているだろう。こういうモデリングだと変化に弱いとか、requirementではあー言ってるが、実際はこういうニーズがあるはずだとか。  

そしてこれらはrequirementを受けての分析を行う際に必要なスキルだろう。これがドメイン駆動設計の戦略部分と一致するのかは怪しいがなんとなく性質的には似てそうだ。  
実際に、ある程度はモデリングが入ってきそうでもある。ただし、筆者の考えでは、ここでおこなったモデリングをそのままプログラム上でモデリングとして落としてはならない。  
プログラムは、大枠の設計を実現するための詳細が語られる場所であり、それらの詳細が組み合わさって大きな視点でrequirementやconsiderationが実現されるものだからだ。  
ミクロな視点では、更に様々な考慮事項があり、それはモデリングにも影響を与える。  

これをconsiderationと読んで、requirementを受けて分析をする形の作業をしておきたい。  

## physical
物理制約も重要な事項になる。筆者はwebシステムばかりやってるので、ブラウザjsがあり、dockerで動くプロセスがあり、DBにアクセスするという一辺倒なシステム構成しか知らない。  
実際には、androidアプリがあったり、組み込み開発があったり、DB上にストアドプロシージャを登録したり、IoTのプロコトルを使ったり、クラウドQueueを使ったりする。  
実際にプログラムを組むことになる際には、プロセスを並列で動かす必要があるかもしれない。  

これらはすべてコンピュータであり、コンピュータの物理的な要因だろう。  
これらの物理的な要因は、requirementの時点で決まったりもするし、アサインされるプログラマの得意なものを選んだりする。  
選ぶ基準についてもいろいろあるが、例えばDBとアプリケーションとブラウザjsというのはかなりオーソドックスなものでいつの間にやら選ばれたりするものだろう。  

いつの間にやら選ばれるので、あまり意識されないが、立ち返ってみれば、別の選択肢もある。また、その制約の上でコードを書くことになる。  
筆者は、設計論というものが、この物理的な要因を意識せずに語られることが多いような気がしていて、違和感が強い。  
実際にはちゃんと語っている書籍もあるであろうはずなので、ちゃんと読まなければならないが。  

パフォーマンスは実のところrequirementに入ってきたりするので、物理要因も検討するべきだ。  

## 大枠の設計まとめ
以下の3つの項目をあげた。
- requirement
- consideration
- physical

順番に説明したが、実際には一つ検討したら、前に立ち返る必要があるだろう。  
requirementを受けてconsiderationを検討したら、隠されたrequirementを明らかにするために再度ヒアリング（対象が自分なら心の声）を行うべきだろう。  
considerationの内容によっては、physicalがオーソドックスな構成から変化を求められるだろうし、それによってrequirementの内容を満たせるかも変わる。  

# 機能設計
この機能設計というやつはwebの文脈になる。もしかしたら他のインフラでも似たような考えが浮かぶかもしれないが、筆者がwebを基本としてきたので。  

## work flow
昔、オブジェクト指向UIというものの記事を見た気がするが、ややこしいモデリングに対しては、crudだけでは処理を定義できない。  
どういう手順で、どう編集していくかの手順が必要で、ユーザが自由にやりたいことができるのではなく、誘導してやる必要がある。  
こういった手続きの流れがあるものも、ないものもあるが、流れがあるならそれらは一連のものとしてグルーピングできるし、単なるcrudなら対象のモデルを中心としてグルーピングすればいいだろう。  

この一連のまとまりをwork flowと呼んでおきたい。  
work flowの中で、利用する機能がいくつか定義され、webであればurl endpointが定義される。  

## 画面設計
画面上に表示する項目は、プログラマレベルで検討できるものは箇条書きでも構わないと考えている。  
ただし、情報の構造は意識し、箇条書きはネストして書いておくべきだ。  

画面設計は、work flowの中で利用されるものなので、work flowから検討できる。  

## db schema
特に説明は不要だろう。  
だが他にも言及すべきことはある。たとえば外部のapiを叩くときには、そのapi schemaが必要だろう。  
クラウドのqueueもある意味では外部システムなので、そこのモデリングも必要になる。  
そういったschemaは定義しておかないと、コードが書きづらい。  

## application model
db schemaで表現できる制約はそちらに譲ればいいが、モデルの動きというか振る舞いというか、紐づく関数群というか、そういうものは事前に定義できれば開発がスムーズになる。  
ここまで来ると、だいぶ内部実装に近い世界になるので、DDDの文脈でドメインエキスパートたるべき経験がないと、やりづらい。  
でも、逆になくても、トランザクションスクリプトから起こして行けばいい。必要な関数は、モデリングの振る舞いとして外に出していく。  
このあたりの経験があれば、共通というか、抽象度を上げた関数は何を定義すべきかわかるだろう。  

# プログラミング

## 基本構造
physicalの項目でも言及したが、プログラムには基本的な構造があるように思う。  
- 入力があって出力がある
- プログラムからプログラムへ再帰的に入出力が行われる
- 入力と出力がある部分はソフトウェアの境界となる

この入力と出力は、physicalの構成の境界で必ず発生する。  
だが、多くの設計理論がこの境界を意識しない、あるいはさせない設計を誘導しているように感じており、筆者の感覚と大きく乖離する。  
大枠の設計の段階では、physicalから導出されるソフトウェア境界など意識しなくれもいいかもしれない。むしろ意識してしまうと、そちらに思考がフォーカスされて大事なことが抜け落ちるかもしれない。physicalはphysicalで考えればよい。  

ただ、プログラミングする段階では意識すべきだろう。  
「一つのことをうまくやる」という単語があるし、関数は抽象化のために切るわけで、切った関数の命名によって概念が伝わり詳細を意識しなくて済む。  
でもその関数の内部では複雑なことをやっているかもしれない。大枠での概念を、そのまま詳細に落とすべきではないと考える。  
詳細を組み合わせることで、大枠の設計を概念的に実現するのだ。  

## テスト
テストはなんのためにするかというと品質を保証し、変更容易性を高めるためだ。  
ソフトウェアは継続的に改修されることを想定するので、この変更容易性は非常に重要な概念だろう。  
テストのために設計するなみたいな言説もあるかもしれない。大枠の設計についてはそうだろう。この段階でテストまで考えて設計はできない。  
ただ、単体テストと呼ばれるような、細かく部品の品質を担保していく作業については、テストをしやすい設計の上で成り立つものだろう。  
本来は、十分に独立した抽象概念にフォーカスできていればテストは容易になりそうなものだが、その十分に独立した抽象概念というやつは、際限なく考えられてしまうし、顕現する形も違う可能性がある。  
単体テストをしやすいという概念は、わかりやすいので設計の方針としては妥当だろう。その結果として、十分に独立した抽象概念の獲得を目指していきたい。  

これらを実現しようとした場合、入出力を行う部分と、行わない部分を分離するというプラクティスがある。いわゆるDIというものだったりする。  
つまり、入出力を行う関数を、関数の引数にいれるというものだ。  
ただ、このDIの概念をテストにフォーカスさせると、入出力ではなく、再現性という観点のほうが正しいだろう。  
つまり入出力がなくても、乱数生成（実際にはあるが）や、sql組み立て、ややこしい計算などは再現性が低く、テストとしては別途フォーカスすべきものだ。  
再現性の観点から、テスト設計はすべきだろう。  

## モデリング
機能設計の段階で、db schemaには言及しているが、実際にはこちらで考えてもいいだろう。  
モデリングというのは、特定のオブジェクトの項目や型を決めることだけではない。  
そもそも型とは言語環境に依存するので、一概に表現できるものではないので、型と言ってもいいのかもしれない。  
要は制約だったり、振る舞いだったりというものだ。  

classベースのオブジェクト指向は、筆者は嫌ってきたが、いざデータ型を定義すると、関連する関数は同じ名前空間に集めたくなった。  
classベースのオブジェクト指向ではレシーバがあって、methodがあるというお約束は存在するが、データ型に関連する関数群を同じ名前空間に集めるのも、まさに振る舞いと言っていいだろう。  
また、クロージャは便利だが、基本的には読みづらい。classというのはクロージャのおばけだという認識なので、クロージャが必要になるのであれば、classを使うべきだろう。  
classの無い言語であっても、特定の構造体に対してinterfaceやらtraitやらを「実装」するという概念が存在する。  

また制約は型で表現しきればものはバリデーションになるかもしれない。本来はアサーションと呼ぶべきだろうか。ここらへんの違いはあまりわかっていない。  

更に関連も重要だ。特定のモデリングを集めた概念の上で関連が示せれば、それはDDDにおいて集約と呼べるべき概念だが、楽ではある。  
単にその名前空間に振る舞いを定義すればいいだけだ。  
ただ、集約がなくても関連があるものもある。これはどちらが振る舞いの主体であるか検討しなくてはならない。  
こういうのが面倒な場合は、class methodではなく、単なる関数のほうが取り回しが良いだろう。でも、どうしても振る舞いにしなくてはならないものもある。  

## 入出力のモデリング
Ruby on Railsは筆者は触ったことがないのだが、似たようなフレームワークでlaravelは常用している。  
laravelはDIやjobと言った仕組みもあり、厳密には違うのだが、基本構成はRESTful+MVC+ActiveRecordだろう。  

これは、モデリングを単一に保ち、すべてをそれで解決する概念のように思う。  
正直最近までMVCとはなにか理解できなかった。いつ誰がDBにアクセスするんだ？という。  
なんのことはない、model自体はアプリケーション上のものとDB上のものを同一として扱える仕組みなので、正解はMになるのだ。  

モデリングは、基本的にアプリケーションのほうが表現が豊かである。制約も自由だし、関連も示しやすい。  
でもDBでなくては表現できない一意性制約というものがある。  
Active Recordは、アプリケーションでもありDBでもあるので、これらの制約をすべてActiveRecordモデルで表現できるという意味で秀逸なデザインだろう。  
RESTfulであれば、MVCのMに対するcrudだけ実装すれば、基本的には事足りる。それらのインタフェース上でやり取りされるデータ型もMを流用できる。  

だが、実際にはこれはそんなにうまくいかないことも多いだろう。特に継続的に改修されるシステムは、requirementが変化しつつも既存のモデルを流用したくなったりする。  
そうなるとモデリングの意味が変化したりするし、制約も増えたりする。  
ユーザから見て、オブジェクト思考UIのようにcrudだけで表現できるアクションだけでは足りなくなったりもする。モデリングが複雑になればなおさらだ。  

既に入出力については述べたが、入出力にもモデリングがあるべきだろう。  
ただし、それはアプリケーションのモデリングよりも機能がすくなくなるはずだ。入出力のinterfaceを表現するものとしてモデリングがある。  
これはwebからのrequestであれば、そのrequest/responseのデータモデルだろう。crudと違う概念であれば、独立して検討すべきだ。  
DBについては、プログラムからプログラムを再帰的に呼び出しているといえる。つまりDB側と通信の際にも入出力があり、そのモデリングがある。  
DBのinterfaceはテーブルだと思われがちだが、筆者の意見は違う。  
sqlこそがinterfaceであり、それらをグルーピングする概念としてtableに倣うのだと考えている。  

この入出力のモデリングは機能が少なくてもよく、内部のアプリケーションでのモデリングに変換されればいいだろう。つまりアプリケーションのモデリングとの変換ロジックを持たせたい。  
Active Recordの説明で一意性制約に言及したが、一意性制約はDBのプロセスが担保するものなので、DBに問い合わせればよく、アプリケーションのモデリングでは表現したくない。この辺りは分離して整理しておきたい。  
その問い合わせの際に、この入出力のモデリングを利用する形だ。  

## 全部盛りプラクティス
基本構造で説明した3つの概念と、テスト容易性を愚直に表現すると以下の要素が必要になる。
- 


# その他
対立する２つ以上の概念に対して、答えをだすことがソリューション。  
求められるのはソリューション  
技術はソリューションではないものも存在するが、それは長生きしないだろう。  
つまり、技術を提供する我々は、それらの対立軸を意識し、適切なソリューションとなる技術的な答えを用意しなくてはならない。  

大枠では、それはrequirementで検討される要求、considerationで検討されるシステム領域つまりドメイン、physicalで検討される物理制約だ。  
これらは対立軸になっていて、相互に検討していかなくてはならない。  
そしてそのソリューションとして、機能設計を行い、プログラミングを行う。  

