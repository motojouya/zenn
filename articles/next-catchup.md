---
title: "Next.js App Routerその周辺と取り扱いの検討"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['Next.js', 'Auth.js']
published: false
---

## Intro
Webアプリケーションを作ったのだが、その際にNext.jsをフレームワークとして利用した。
選定した理由、使い方、足りない部分をどう補ったかなどを記載していく。

## ライブラリの選定

### React
筆者はReactで開発する体験が素晴らしいと思っているので、ブラウザUIは基本的にはReactで書きたい。
ほぼほぼ以下の記事で言及されている内容と同じことを思っている。
https://qiita.com/uhyo/items/ff243a5771077aaf4b5b

Reactを選んだ時点で、メタフレームワークとしての選択肢は限られてくる。
他にもあるだろうが、メジャーどころではNext.jsとRemixだろう。
ここからは、Next.js App Router（以降App Router）とRemixを比較して行く。

### Web Standard
RemixとNext.jsを比較したときに、槍玉に上がりやすいのは、[Remix](https://remix.run/)のトップページに書かれている以下の文言だろう。
`Focused on web standards and modern web app UX, you’re simply going to build better websites`

特にNext.jsはfetchのパッチを当てていると言及される。
Web標準と章立てしたが、基本的にはfetch APIに絞って展開していく。

ただ、いろんなフレームワークを見るとfetchにはパッチを当てているケースが多い。以下ははremixのコードだ。
https://github.com/remix-run/remix/blob/main/packages/remix-node/globals.ts#L42
```ts
global.fetch = undiciFetch;
```

詳しく追っていないので解説することは避けるけども、Nodeのversionによってはサーバサイドでfetchが使えないためにパッチを当てているというのはなんとなく予想がつく。
以下の記事は参考になるかもしれない。
https://yosuke-furukawa.hatenablog.com/entry/2022/12/05/103008

クライアントサイドのfetchへのパッチが問題だ！といえばそうだが、フレームワークというのは基本的な機能を使うために何かしら標準APIを補助することが必要だ。という視点もあるのではないかと感じた。
つまり、パッチを当てるということ自体は批判すべきことではない。パッチの当て方が問題だし、不必要なパッチを当てないようにしないと行けない。

Next.jsのパッチは、以下のページで説明されているが、基本的な標準APIとしては使えつつも、別のオプションが使えるという仕様になっている。
https://nextjs.org/docs/app/api-reference/functions/fetch

つまり、通常通りのfetch関数は使えつつも、少し拡張しているということになる。
基本的な挙動は変更させていないのだから、確かにそんなに変なことはやっていないなという印象を持った。
もちろんそれならば`nextFetch`みたいな関数を切り、それを使ってもらうように誘導できなかったのか？という疑問は当然残る。
実害ではなく必要性を論点にすればネガティブな印象になる。

詳細に迫るのはこのあたりで止めておくが、筆者の意見としてはそういう視点もあるのだから、Web標準じゃないからとNext.jsを嫌いすぎる必要はないだろうという意見だ。
ただ、筆者としてもWeb標準を遵守しますというポリシーを掲げているフレームワークのほうが安心できる。将来にわたって混乱が少なそうなのはポリシーを掲げている側だろう。
この視点で選ぶなら、Remixのほうがポジティブだ。

### Server Side
App Routerの目玉はやはりReact Server Componentだ。（以降はRSC）
これ自体はReactの機能だが、現時点では実質App Routerでしか利用できず、App Routerの機能と表現しても差し支えないだろう。

RSCは、それ自体がいろんな要素が詰まったものであり、今までのgetServerSidePropsとだけ比較するべくものではない。
ただ、Remixの機能と比較する際には、サーバサイドのロジックをどうするかという視点で比較できるだろう。

視点としては、以下があるだろう。
a. Web API Endpointを用意する機能
b. React Componentから参照し、サーバサイドからデータを取得(GET)する機能
c. React Componentから参照し、サーバサイドのデータを更新(POST)する機能

App Routerにおいては、以下となる
a. Route Handlers
b. RSC
c. Server Actions

Remixにおいては以下だ
a. loader, action関数
b. loader関数
c. action関数

Remixでは、同一pathに配置したファイルに、exportするコンポーネントがなければ、そのままAPI Endpointになる。
機能の設計としては、Remixのほうが単純で理解がし易いという印象がある。

ただ、上記だけで比較するのは早計であり、実現できる状況を想定したほうがよい。

Remixにおいては、特定のコンポーネントから参照できるloaderやaction関数は一つのようだ。
したがって、特定のコンポーネントで複数回サーバサイドに問い合わせを行う場面においては、loader関数内で処理を分岐させるなどの工夫が必要になる。

これは、RSCにおいても構造上は同様で、RSC内で定義したデータを取得するしかない。
ただ、React Componentというのは、特定のデータの表現であり、多様なデータを受け入れるような設計は、基本的にしないほうがいいだろう。
Remixにおいては、Nested Routeという機能で、複数のファイル（つまり複数のloader関数）を組み合わせる方法もある。
RSCでも、取得するデータが違うなら、別のRSCを用意すべきだろう。

ただ、上記はデータ取得を想定した状況であり、POSTな処理においては、特定のコンポーネントから、複数のパターンのPOST処理を利用できる状況も考えられるだろう。
App RouterのServer Actionsは、Formと紐づけて呼び出すこともできるし、単純に副作用を起こす関数として呼び出すこともできる。複数種類を混ぜ込める。
Remixのaction関数はそういう風になっていないので、少し工夫が必要そうだ。

今回、筆者が開発したアプリケーションは、無限スクロールの実装がある。
これはGETの処理だが、RSCの機能での実現は難しく感じた。したがってbの機能は使わず、aの機能で実装する形を取った。
Remixであれば、bの機能で、複数回アクセスしてデータ取得できるはずなので、そういった違いもある。

サーバサイドの機能に焦点を絞ると、上記のような細かい違いが存在する。
実質的にaのEndpointを切ってしまえばどうとでもなるので、結局のところ実現したい画面はどちらでも実装可能だ。

すでに述べた通り、RSCは上記の比較以上の影響を持った技術要素なので、RSCの機能をフルに使いたいならApp Routerを採用するだろう。
反面、できることが絞られ、わかりやすいのはRemixのほうだと感じる。
App Routerの流儀に沿った実装を習うのか、あるいはプログラマが考えてRemixのAPIを利用するのかは、考え方によるのかもしれない。

### Static Export
静的出力は、Remixには当初機能がなかったが、SPAモードが追加され、一つのファイルであれば出力が可能になった。
Next.jsは、静的出力が可能だが、SPAモードのように一つのファイルにまとめるのではなく、path毎にhtmlを出力してくれる。

一つのファイルサイズとしてはRemixのほうが重たくなるはずだが、取り回しやしやすそうだ。
反面、NginxなどのWebサーバから見て自然なのはNext.jsのほうだろう。
そうった視点もあるが、ここでは動的pathについてより詳しく言及したい。

前提として静的出力するということは、サーバサイドで動くRuntimeを想定しないということだ。つまり動的pathには基本的に対応できない。
クライアントサイドで、画面遷移した場合には動的にpathを書き換えて表示できるが、初期表示時にhtmlファイルを取得することはできない。という意味だ。

Next.jsの場合は、コンポーネントが動的pathを想定している場合、その動的pathのパターンをすべて網羅して静的出力する機能がある。
実装としては動的なのだが、すべてのパターンをビルド時に解決できるなら、この方法は最適だろう。
https://nextjs.org/docs/app/building-your-application/routing/dynamic-routes#generating-static-params

Remixはそういう機能はなく、割り切った実装だ。
Next.jsの場合でも、ビルド時に解決が難しい動的pathの場合は、当然対応できない。
そういう意味ではRemixのほうが、ある意味わかりやすい。

ビルド時に解決が難しい動的pathの場合どうするかというと、404.htmlを使う形となる。
これは実質どちらも同様に404.htmlを用意する必要がある。

ちなみに今回は静的出力の機能は利用しない。
なので比較軸としては採用しないものだが、特徴的な機能なので言及しておく。

### AuthN/Z
AuthN/ZはAutheNtication（認証）、AuthoriZation（認可）のこと。
Auth.jsはApp RouterでもRemixでも利用できるが、App Routerの場合はデファクトスタンダードであり、他の選択肢は検討に上がらなかった。
反面、Remixはremix-authがある。
Auth.jsとremix-authは特徴がだいぶ違うので、App RouterとRemixの比較要素としてあげたほうがよいと判断した。


認証は、IDパスワードの管理など、面倒が多いので外部に頼りたい。
有料のサービスではなく、ライブラリから外部のIDプロバイダーを利用したい。
Next.jsにおいては、Auth.jsの利用がデファクトスタンダードのようだった。

Auth.jsを見て最初にギョッとしたのは、DBスキーマの強制だ。
以下はPrismaの例だが、指定されたスキーマを作らなくてはならない。
https://authjs.dev/getting-started/adapters/prisma

ライブラリは、基本的に機能を提供し、それにあったスキーマを設計し、状況によってはそのスキーマを改修しながらアプリケーションを育てていくものだと考える。
そう考えていたので、ライブラリにスキーマを指定されるというのは面食らった。

Remixにおいては、remix-authがある。remix-authならばスキーマを指定しない。
反面、DBに認可の連携情報を記録するのは、自分で実装しなければならないようだった。
https://remix.run/resources/remix-auth

ここも基本的にはスキーマ設計というのはアプリケーションエンジニアのコントロール領域だという考えから、remix-authのほうがポジティブに感じる。
ただ、IDプロバイダーからの情報や、セッション管理の情報などは、基本的な考え方があるはずで、たしかに理想的なスキーマは指定の形に落ち着くかもしれない。
また、スキーマを改修する際も、拡張情報ならば別テーブルを用意したほうが理想的になる場面も多そうだ。つまりAuth.jsの指定するスキーマを改修することは想定しなくていい。

そう考えるならば、Next.js App RouterでAuth.jsになれるほうがいいだろうと考えた。
ただ、Auth.jsはなるべくアプリケーションのコードからは隔離したい。
Auth.jsのスキーマをなるべく意識せず、またAuth.jsから切り替えやすくしておきたい。

### Start Up
Remixは組み込みサーバでも動く。起動プログラムを書いて、ライブラリとしてRemixをimportして起動することが可能なので、起動時のカスタマイズができる。
Next.jsはそういったことはできず、Next.jsを起動しなくてはならない。どこかにstart up時のhookくらいはありそうだが、調べきれなかった。

### 結論
Remixのほうができることが少なく、プログラマが自分で考えて実装しやすい。Web標準というポリシーも掲げ、わかりやすい作りになっていそうだ。
反面、Reactの最新機能である、RSCを使うのであればApp Router一択となる。
今回は、好きなReactの最新機能にキャッチアップしたいという点が勝り、App Routerを採用した。

仕事で採用するなら、もっと他の細かい機能要件を比較し、不足がないことを確認する必要がある。
一休さんのRemix乗り換えの記事の内容までは、この記事では言及できていない。
https://user-first.ikyu.co.jp/entry/2023/12/15/093427

ただ、App RouterもRemixも機能要件を満たしているのであれば、仕事なら安定性やカスタマイズ性を重視し、Remixを採用するだろう。

## 不足の機能
Next.jsはWebフロントエンドのためのフレームワークであり、サーバサイドの機能をあまり持たない。
API Routeでリクエストを受け付けることができるが、受け付けるだけでその後のことは何もしてくれない。

基本的にはリレーショナルデータベースを利用するので、PrismaなりのDBアクセスライブラリは利用するとして、そこに至るまでのアプリケーションの記載を支援する仕組みが必要になる。
- Session管理
- リクエストハンドリング
- DI
- トランザクション管理
- ロギング

### Session管理
Session管理は、Auth.jsに任せることになる。
- clientからアクセスしない
- サーバサイドでもuser_idのみ引き渡す形とする

機能としては、後述するリクエストハンドリングを行う部分に実装を差し込む。

### リクエストハンドリング
よくある事例なので、サンプルコードのURLを記載する。
機能としてAuth.js、formとjsonを分ける。server actions用のものも用意するなどには言及したい。

### DI
Context Binderについて
別の領域を取って解説したほうがいいかも。後述するというような

### トランザクション管理
トランザクションの処理は、フレームワーク的な機能としては用意しなかった。
コンテナ環境へのデプロイであり、オブジェクトストレージへのアクセス、外部サービスへのアクセスなど、DB以外のIOも多様にある状況においては、一辺倒なトランザクション管理は適切でないと考えたため。

特定のコードをmiddlewareのような機能で囲い、そのmiddleware上でトランザクションが管理されるような形では、そのコードの中でオブジェクトストレージにアクセスした際に発生するエラーハンドリングを、DBのエラーハンドリングをコントロールしづらくなる。
そのように考えたため、アプリケーションのコードからトランザクションを開ける仕組みとした。これはフレームワーク側の機能ではないので、DBアクセスへの解説記事にて後日言及する。

TODO サンプルコードあったほうがいいかも。反例として。

### ロギング
ロギングは今回は実装していない。
本当は考えなくてはならないのであげたが、今回は検討していないので解説しない。


## DIモジュールについて
テストが目的で、最小限のコード

## 考えたかた
難解な機能は避けつつ、メタなコードはアプリケーションに必要。選んで機能が重複しないように
またライブラリ寄りならしかたないがアプリはより注意深く
tsの型レベルプログラミングも、自由にするのではなく、1-100までの整数や、stringのunionのような、プログラマが把握できる制約まで狭めた範囲ならよい。


## DIとは
classの上に乗せた機能だが、classの考え方を基本にするなら、自然な機能

- DI
  - classベースの考え方
- DIコンテナ
- 関数において先にbindすること

## DIの目的
- テスト
- 実装の切り替え
  - 将来的
  - 現在の実装

## ライブラリの扱い
wrapしましょう
- 付け替えを内部でできる
- ライブラリ利用のスコープを限定
- ライブラリの違いを吸収
  - 引数
  - 戻り値
  - 例外

## 実装の付け替え
実装として、アプリケーションの中で付け替えるのであれば、DIコンテナではないはず。
アプリケーションの機能として実装するのだから、DIはしてもコンテナで管理の必要はないのでは

## テスト
必要。ただし、主たる処理があり、サブな位置づけで

## 関数での実装
コードと利用例

## 特徴
上記コードの特徴とpros/cons

## つらみ
多重でDIする際には、生成知識がいる。
いずれにしろ、生成知識というやつは、アプリケーションコード上に実装する。
量が多ければ難しくなる。

けれど、多重にするにしても、2レイヤ程度ではないか
`ユースケース -> サービス -> リポジトリ`

ただし、この構造では、ユースケースがリポジトリの何にアクセスしているか、知らない。
外界に作用を引き起こす処理がなんなのか、ユースケース上で把握できるのは、よいこと。

関数なら、callbackを渡すことで、比較的かんたんにDIっぽい動きができるので、コード量もすくなくて済みやすい。

### 難しい機能
mapped typeをどこまで使うべきか。型のバリエーションに制限があるなら。任意の文字列ではなく、固定の文字列の羅列までならいいのでは

## outro

※Remixについては、最終的に採用しておらず、上記の認識がずれているかもしれない。気になった方にはご指摘いただきたい。

