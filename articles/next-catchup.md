---
title: "Next.js App Routerその周辺と取り扱いの検討"
emoji: "🙌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ['Next.js', 'Auth.js']
published: false
---

## Intro
Webアプリケーションを作ったのだが、その際にNext.jsをフレームワークとして利用した。
選定した理由、使い方、足りない部分をどう補ったかなどを記載していく。

## 選定

### React
筆者はReactで開発する体験が素晴らしいと思っているので、ブラウザUIは基本的にはReactで書きたい。
ほぼほぼ以下の記事で言及されている内容と同じことを思っている。
https://qiita.com/uhyo/items/ff243a5771077aaf4b5b

### Next.js App Router
Reactを選んだ時点で、メタフレームワークとしての選択肢は限られてくる。
他にもあるだろうが、メジャーどころではNext.jsとRemixだろう。

RemixとNext.jsを比較したときに、槍玉に上がりやすいのは、[Remix](https://remix.run/)のトップページに書かれている以下の文言だろう。
`Focused on web standards and modern web app UX, you’re simply going to build better websites`

特にNext.jsはfetchのパッチを当てていると言及される。
ただ、いろんなフレームワークを見るとだいたい以下のコードは見つかる。
```
global.fetch = undiciFetch;
```
上記はremixのコードだ。
https://github.com/remix-run/remix/blob/main/packages/remix-node/globals.ts#L42

詳しく追っていないので解説することは避けるけども、Nodeのversionによってはサーバサイドでfetchが使えないためにパッチを当てているというのはなんとなく予想がつく。
以下の記事は参考になるかもしれない。
https://yosuke-furukawa.hatenablog.com/entry/2022/12/05/103008

クライアントサイドのfetchへのパッチが問題だ！といえばそうだが、フレームワークというのは基本的な機能を使うために何かしら標準APIを補助することが必要だ。という視点もあるのではないかと感じた。

この件は厳密に言及したいのではなく、そういう視点もあるのだから、Web標準じゃないからとNext.jsを嫌いすぎる必要はないだろうという意見だ。
筆者としてもWeb標準を遵守しますというポリシーを掲げているフレームワークのほうが安心だし、Next.jsもRemixも機能要件を満たしているならば、安定したサービスを提供したい場面においてはRemixを推したい。

ただ、今回開発するものは、自分が自分のために作るもであり、学習目的という要素もあった。
筆者はReactは好きなので、React Server Componentはキャッチアップし、RSCにあった設計ができるスキルをかじっておきたい。

### サーバサイドとの連携
TODO
Next.jsのRSCとserver actionに対して、remixのloaderとactionがどう対応しているか。
それぞれの対応範囲や夏季やすさについて

vs remix
- form
  - server components & server action
    - 自由度は高いが、知識がいる
  - loader
    - わかりやすいが画面に従属
  - nested layoutでの実現
  - 無限スクロールではremixならできるがnextはroute handler必要
- 無限スクロールのfetch
  server actionsを使うやり方もありそう
  https://zenn.dev/akfm/books/nextjs-basic-principle/viewer/part_1_interactive_fetch
  ただ、postでデータ取得するの抵抗ある

### 静的出力
remixはたぶん静的出力するならSPAモードだけっぽい。
next.jsはwebサーバに置くhtmlファイルをそのまま出力できるのが利点。
ただし、動的なpathは解決方法を用意しなければならない。

remixのspaモードも同様で、動的なpathどころか`/`以外のアクセスにはファイルが存在しないので、404.htmlなどで補う点は同じ。
これは今回の比較軸ではないが、メモ的に記載しておく。

### Auth.js
認証は、IDパスワードの管理など、面倒が多いので外部に頼りたい。
有料のサービスではなく、ライブラリから外部のIDプロバイダーを利用したい。
Next.jsにおいては、Auth.jsの利用がデファクトスタンダードのようだった。

Auth.jsを見て最初にギョッとしたのは、DBスキーマの強制だ。
以下はPrismaの例だが、指定されたスキーマを作らなくてはならない。
https://authjs.dev/getting-started/adapters/prisma

ライブラリは、基本的に機能を提供し、それにあったスキーマを設計し、状況によってはそのスキーマを改修しながらアプリケーションを育てていくものだと考える。
そう考えていたので、ライブラリにスキーマを指定されるというのは面食らった。

Remixにおいては、remix-authがある。remix-authならばスキーマを指定しない。
反面、DBに認可の連携情報を記録するのは、自分で実装しなければならないようだった。
https://remix.run/resources/remix-auth

ここも基本的にはスキーマ設計というのはアプリケーションエンジニアのコントロール領域だという考えから、remix-authのほうがポジティブに感じる。
ただ、IDプロバイダーからの情報や、セッション管理の情報などは、基本的な考え方があるはずで、たしかに理想的なスキーマは指定の形に落ち着くかもしれない。
また、スキーマを改修する際も、拡張情報ならば別テーブルを用意したほうが理想的になる場面も多そうだ。つまりAuth.jsの指定するスキーマを改修することは想定しなくていい。

そう考えるならば、Next.js App RouterでAuth.jsになれるほうがいいだろうと考えた。
ただ、Auth.jsはなるべくアプリケーションのコードからは隔離したい。
Auth.jsのスキーマをなるべく意識せず、またAuth.jsから切り替えやすくしておきたい。

## 不足の機能
Next.jsはWebフロントエンドのためのフレームワークであり、サーバサイドの機能をあまり持たない。
API Routeでリクエストを受け付けることができるが、受け付けるだけでその後のことは何もしてくれない。

基本的にはリレーショナルデータベースを利用するので、PrismaなりのDBアクセスライブラリは利用するとして、そこに至るまでのアプリケーションの記載を支援する仕組みが必要になる。
- Session管理
- リクエストハンドリング
- DI
- トランザクション管理
- ロギング

### Session管理
Session管理は、Auth.jsに任せることになる。
- clientからアクセスしない
- サーバサイドでもuser_idのみ引き渡す形とする

機能としては、後述するリクエストハンドリングを行う部分に実装を差し込む。

### リクエストハンドリング
よくある事例なので、サンプルコードのURLを記載する。
機能としてAuth.js、formとjsonを分ける。server actions用のものも用意するなどには言及したい。

### DI
Context Binderについて
別の領域を取って解説したほうがいいかも。後述するというような

### トランザクション管理
トランザクションの処理は、フレームワーク的な機能としては用意しなかった。
コンテナ環境へのデプロイであり、オブジェクトストレージへのアクセス、外部サービスへのアクセスなど、DB以外のIOも多様にある状況においては、一辺倒なトランザクション管理は適切でないと考えたため。

特定のコードをmiddlewareのような機能で囲い、そのmiddleware上でトランザクションが管理されるような形では、そのコードの中でオブジェクトストレージにアクセスした際に発生するエラーハンドリングを、DBのエラーハンドリングをコントロールしづらくなる。
そのように考えたため、アプリケーションのコードからトランザクションを開ける仕組みとした。これはフレームワーク側の機能ではないので、DBアクセスへの解説記事にて後日言及する。

TODO サンプルコードあったほうがいいかも。反例として。

### ロギング
ロギングは今回は実装していない。
本当は考えなくてはならないのであげたが、今回は検討していないので解説しない。


## DIモジュールについて
テストが目的で、最小限のコード

## 考えたかた
難解な機能は避けつつ、メタなコードはアプリケーションに必要。選んで機能が重複しないように
またライブラリ寄りならしかたないがアプリはより注意深く
tsの型レベルプログラミングも、自由にするのではなく、1-100までの整数や、stringのunionのような、プログラマが把握できる制約まで狭めた範囲ならよい。


## DIとは
classの上に乗せた機能だが、classの考え方を基本にするなら、自然な機能

- DI
  - classベースの考え方
- DIコンテナ
- 関数において先にbindすること

## DIの目的
- テスト
- 実装の切り替え
  - 将来的
  - 現在の実装

## ライブラリの扱い
wrapしましょう
- 付け替えを内部でできる
- ライブラリ利用のスコープを限定
- ライブラリの違いを吸収
  - 引数
  - 戻り値
  - 例外

## 実装の付け替え
実装として、アプリケーションの中で付け替えるのであれば、DIコンテナではないはず。
アプリケーションの機能として実装するのだから、DIはしてもコンテナで管理の必要はないのでは

## テスト
必要。ただし、主たる処理があり、サブな位置づけで

## 関数での実装
コードと利用例

## 特徴
上記コードの特徴とpros/cons

## つらみ
多重でDIする際には、生成知識がいる。
いずれにしろ、生成知識というやつは、アプリケーションコード上に実装する。
量が多ければ難しくなる。

けれど、多重にするにしても、2レイヤ程度ではないか
`ユースケース -> サービス -> リポジトリ`

ただし、この構造では、ユースケースがリポジトリの何にアクセスしているか、知らない。
外界に作用を引き起こす処理がなんなのか、ユースケース上で把握できるのは、よいこと。

関数なら、callbackを渡すことで、比較的かんたんにDIっぽい動きができるので、コード量もすくなくて済みやすい。

## outro

