---
title: "リスト操作の書き方について"
emoji: "😺"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "Go"]
published: false
---

# Intro
先日、このスライドを見たのだが、最近は自分もリスト操作に対して、どう実装するか考えることが多く、記事にしておきたい。
https://speakerdeck.com/syumai/go-generics-slice-manipulation

上記の記事はGo言語で、リスト操作する際に、for文ではなく、mapやfilterのような関数を紹介している。
この記事では、それらの関数、for文、またリストを引数に取る関数を実装する際のことなど、検討していきたい。

サンプルコードはTypeScriptだったり、Go言語だったりするが、そこはご容赦いただきたい。

# やらないこと
この記事はリスト操作についてなので、無限ループや、アプリケーションから見て無限に見えるリストは扱わない。
後者については、後でちょっとだけ言及する。
前者は以下のようなものだ。

```typescript
for (;;) {
  if (confirm("終了しますか？")) {
    break;
  }
}
```

上記を1行で書くと、以下のようになるわけだが、chrome devtoolsのコンソールで実行すると、okとしない限り、無限に確認ダイアログが表示される。  
`for (;;) { if (confirm("終了しますか？")) { break; } }`

while文でも実現できるが、for文は上記のようなこともできる。こういった使い方には言及しない。

# 構成検討
- 紹介
  - for文
  - map, filter, reduce
  - find
  - some, every
  - each
  - intersect, grouping
- 使いわけ 
  - immutable文脈ではeachは使わない
  - そもそもIOがあるなら、for文。名前空間を切りたくない。returnしたいなど
  - 短いリストなら、何度もループ回してもそんなコストじゃない
  - 逆に長いならbreakできるfor文。永続化もするだろうし
- 関数を切る
  - リストだけ持つオブジェクトの問題点
  - モデルの振る舞いとしてのリスト操作の想定
  - golangのsambar/loでは多すぎる
  - 実用関数の実装
- indexを扱う
  - 他では特定できない
  - ユーザ入力。react、csv
- transduce
  - router、react
  - filter、map
  - ちょっと難しい
- 落ち穂ひろい
  - dbの値はsortして、無限長を想定 -> cascading reducer
  - リスト内包表記

# 構文や関数の確認
## for
## while
- 無限ループ
  - リスト操作じゃない
## Map
## Filter
## Reduce
## Find
## Some, Every
## Each
## Intersect
## Group
## その他

# リスト構造というモデリング
## モデリングの定義
- someがdoする。値が振る舞う
- classが嫌いで、typescriptではclassを使わなかったが、いやいやどうして、関連する値に対して関数を集めるほうが自然だと感じるようになった。
- classの再発見
- listもモデリングとして捉えると、その振る舞いと考えても良いかもしれない
- モデリングとして捉えるなら、後述するパフォーマンスの問題もあるので、件数が絞れるとよい。ECサイトで言えば、cartに入れられる商品リストの長さは100までにするとか

## SomethingList class
- Xのリストクラスというものを実装する人がいて、僕は何度かreview approveしたことがある。
- でも、リストインタフェースの関数、つまり振る舞いが隠蔽されて使えなくなる。
- 公開しないのがいいというならいいが、個人的な経験としては、わざわざfacade関数を定義するのは、面倒に感じる。

## 叙述関数
- リスト操作を更にアレンジする叙述関数という単語
- 叙述とは、まさに振る舞いということにも感じる。正確にはしらん。
- Xのリストであれば、Xの振る舞いである叙述関数を与えて、Xのリストの振る舞いと捉え直すこともできそう
- でもfilterやmapに叙述関数を与えるというのは、これらを解決できる。
- 叙述関数は、なるべく定義済のものを使いたい。命名されて、叙述の意味が明確になり、振る舞いとして認識しやすくなるから
- 逆に命名がうまくいかない関数なのであれば、そもそも計算概念がややこしいので、for文で書くほうがいいかもしれない

## receiver
- classのように、receiverありきで設計されるものは、このlistの関数とは相性が悪い。例示したい。読みづらくなる。
- golangのreceiverは、実質第一引数なので、僕個人としては、どちらでもいい。
  - どちらかというと高階関数を使うと、読みづらいと感じることが多いので、こうしている。一つの原因としては、無名のインライン関数で、意味的に理解しづらいからだ。
  - receiverとかになると、命名をがんばるようになるので、読みやすくなる。
- receiverの場合でも、以下のようにgenericsの代替実装みたいなものは実現できる。
  - https://mattn.kaoriya.net/software/lang/go/20170309201506.htm
  - ただ、どちらがいいのか、どう違うか、個人的にできていないので、今後検討していきたい。

## その他の構造(横道)
- 横道だが、listについては、JavaScriptもGoも組み込みの構造体がある。
- だがtreeやgraphのような構造体は、組み込みではない。
- 一口にtreeと行っても種類があるし、特定のアプリケーションにおいては、genericなものではなく、1種類のデータ型で十分なことも多い。
- つまり、listに関しては組み込みを使うほうがいいが、よりややこしい構造については、単純に独自classの実装でいいのではないかと思う。
- こういった言説が適用できない領域もあるので、一概には言えないが、筆者が経験してきた領域については、それで十分なことが多い。

# 使い分け
## 文脈
- immutable文脈ではeachは使わない
- ioがあるなら、振る舞いたり得ないので、for文のほうが良いだろう。
- ただ、active record patternを使っていると、DBへのアクションですら振る舞いチックなものなので、そのあたりは再定義して使えばいい
  - 余談だが、最近active record patternと和解した。素晴らしい設計である一面が見えたので。ただ、僕は推奨することはないとは思う。
- 複雑な処理なら、関数を切って、その内部でfor文を使うのが良いだろう。
- for文の中身が意味的に分解できるのであれば、それを関数に切り出すのが良い。
- ただ、for文の中身全体を一つの関数にできるときは、逆に叙述関数として、reduceに渡せる可能性もある。
- `AddItem = (Order, Item) => Order` `reduce([]Item, AddItem, Order)` のようにできる
- AddItemの問題点は、Order側が知る制約であるItemの件数や、Itemのuniquenessを何度も検査しなくてはならないこと。

## パフォーマンス
- 短いリストなら、何度もループ回してもそんなコストじゃない
- 逆に長いならbreakできるfor文。永続化もするだろうし
- 何回回してもいいのであれば、for文でblockを作るよりも、listの振る舞いを何度か呼び出すほうが、コードの見通しが良い。
- このあたりは、データ量に対して、計算量がどれだけあるかだが、例えばitemが20点までなら、何度も検査するのも、そこまで対した計算コストという印象はない。そう考えるならIOのコストのほうがよっぽど膨大になる。
- webの現場では、読みやすさが重視されて、書き直しのコストを下げる傾向がある気がする。パフォーマンスシビアであれば、そこまで気にするプロジェクトもあるはず。

## indexを扱う
- 他ではデータを特定できない
- ユーザ入力なんかに多い
- react, csvとか。reactは特にlistにkeyを与える必要があって、一意な番号が無いときに使ったりする
- ユーザ入力を多く扱うフロントは結構必要になる印象があるが、サーバサイドでは、あまり必要ない印象がある。ただ、これは印象
- 個人的にはjavascriptでは必要だが、Goでindexがいるときはfor文にする。という方に倒しても良い気がしている。このあたりは、今後の検討課題。
- syumaiさんの紹介ライブラリも、indexを無視する関数を挟んだりと、涙ぐましい。indexは、モデリングの観点で、list側のもので、要素側のものではないので、叙述関数を振る舞いとするなら、不要になる。

# 実用関数
- lodash、sambar/loなどのライブラリは、便利な関数が多いが多すぎる。
- その割に実装が単純
- ライブラリは、今までに述べた視点より、より多くのアプリケーションを想定するので、当然そうなる。
- 冒頭のsyumaiさんのスライドのように、アプリケーションで必要なのが数個の関数であれば、ライブラリというよりは、snippetとして、実装しておくのも一つの手だろう。
- 筆者は、以下を定義した。
- groupは、まー想像通り
- intersectは、match部分だけでは足りないので、diff部分も認識できるようにした。これは保存済みのリストを、ユーザ入力のリストで更新したいときに、マッチするだけではなく、違うものを新規追加したりという要件もあるからだ。
- relateは、筆者の好みで。クエリの結果をmergeするときに使うもの。sql直接書きたい派なので、ormapperのrelation機能を代替する関数として使うもの。
  - goはいま実装してるやつ
  - typescriptはproperty名を受けて、mapped typeでやってるやつ
  - queryと組み合わせる例も。window関数で件数をしぼって取る例示も

# 無限のリスト、パフォーマンス
- transduceで、関数をつなげて、一つのループで処理する
- transduceはrouterや、reactのcomponentを結合する際にも使われる
- cascading reducerというのも作った。これは、sqlとして結合済みのリストを、構造体に置き換えながら処理できるようにしたいから。ちなみにsort済みであることが想定されている
- 逆に別れたリストをmergeする関数も必要かもね。
- バッチとか書くときはいるかも
- uiはそもそも表示しきれないので、そんなに長い無限のリストは扱えない。基本はsqlでgroup byで集約するほうがいい。
- relateで例示したが、sqlで子オブジェクトを取ってくるときは、window関数で件数制限する方法もある。これでリストの件数を抑えられる。
- 最近バッチ書いてないので、あんまり知見ないが

# 落ち穂ひろい
- list内包表記
- 基本は、filterや、mapを使う際のルールを適用で良いだろう。副作用がない、IOがない、叙述関数として意味がシンプル。
- でもpythonもhaskellもまともに書いたことないのでわからない

# Outro





